<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="./images/pong.png" type="image/x-icon">
    <title>Pong</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10; // distancia de la cámara

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const sphereGeometry = new THREE.SphereGeometry(0.3, 27, 27);
        const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0x87CEEB, metalness: 0.5, roughness: 0.5 });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.position.set(0, 0, 0);
        scene.add(sphere);
        
        const paddleGeometry = new THREE.BoxGeometry(0.2, 2, 0.1);
        const paddleMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const paddleLeft = new THREE.Mesh(paddleGeometry, paddleMaterial);
        paddleLeft.position.x = -10; 
        paddleLeft.position.y = 0; 
        scene.add(paddleLeft);
        
        const paddleRight = new THREE.Mesh(paddleGeometry, paddleMaterial);
        paddleRight.position.x = 10; 
        paddleRight.position.y = 0; 
        scene.add(paddleRight);
        
        const borderMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
        const points = [];
        points.push(new THREE.Vector3(-10.5, 4, 0)); // Esquina superior izquierda
        points.push(new THREE.Vector3(10.5, 4, 0)); // Esquina superior derecha
        points.push(new THREE.Vector3(10.5, -4, 0)); // Esquina inferior derecha
        points.push(new THREE.Vector3(-10.5, -4, 0)); // Esquina inferior izquierda
        points.push(new THREE.Vector3(-10.5, 4, 0)); // Esquina superior izquierda
        
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const border = new THREE.LineSegments(geometry, borderMaterial);
        scene.add(border);
        
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);
        
        let ballSpeedX = (Math.random() < 0.5 ? -1 : 1) * 0.15;
        let ballSpeedY = (Math.random() < 0.5 ? -1 : 1) * 0.1; 
        let playerText;
        let IAText;
        let loadfont;
        let pointsPlayer = 0;
        let pointsIA = 0;
        const aiSpeed = 0.1;

        // movimiento fluido
        let paddleSpeed = 0.1;
        let movePaddleLeft = 0
        let targetPaddleLeftY = paddleLeft.position.y;

        function createText(text, position, font, textMaterial) {
            const textGeometry = new THREE.TextGeometry(text, {
                font: font,
                size: 0.5,
                height: 0.1,
                curveSegments: 12, // Suavidad
                bevelEnabled: true, // biselado para el borde
                bevelThickness: 0.03,
                bevelSize: 0.02,
                bevelSegments: 5
            });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.set(position.x, position.y, position.z);
            return textMesh;
        }

        const loader = new THREE.FontLoader();
        loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function (font) {
            loadfont = font;
            const textMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            playerText = createText("Player X: " + pointsPlayer, new THREE.Vector3(-10, 4.5, 0), font, textMaterial);
            IAText = createText("IA: " + pointsIA, new THREE.Vector3(7, 4.5, 0), font, textMaterial);
            scene.add(playerText);
            scene.add(IAText);
        });

        function animate() {
            requestAnimationFrame(animate);

            // Actualizar la posición de la bola
            sphere.position.x += ballSpeedX;
            sphere.position.y += ballSpeedY;
            
            checkIfLost();

            // Colisiones con los bordes del campo
            if (sphere.position.y > 4 || sphere.position.y < -4) {
                ballSpeedY *= -1;
            }

            checkPaddleCollision();
            
            if (ballSpeedX > 0) moveAI();

            if (movePaddleLeft === 1) {
                targetPaddleLeftY += paddleSpeed;
            } else if (movePaddleLeft === -1) {
                targetPaddleLeftY -= paddleSpeed;
            }

            targetPaddleLeftY = THREE.MathUtils.clamp(targetPaddleLeftY, -3, 3);
            paddleLeft.position.y = THREE.MathUtils.lerp(paddleLeft.position.y, targetPaddleLeftY, 0.1);
            paddleRight.position.y = THREE.MathUtils.clamp(paddleRight.position.y, -3, 3);

            renderer.render(scene, camera);
        }
        animate();

        function resetBall() {
            sphere.position.set(0, 0, 0);
            ballSpeedX = (Math.random() < 0.5 ? -1 : 1) * 0.15;
            ballSpeedY = (Math.random() < 0.5 ? -1 : 1) * 0.1;
        }

        function reprint(name,points) {
            if (name == 'IA')
            {
                IAText.geometry.dispose(); // Eliminamos anterior
                IAText.geometry = new THREE.TextGeometry(name + " " + points, {
                    font: loadfont,
                    size: 0.5,
                    height: 0.1,
                    curveSegments: 12, // Suavidad
                    bevelEnabled: true, // biselado para el borde
                    bevelThickness: 0.03,
                    bevelSize: 0.02,
                    bevelSegments: 5
                });
            }
            else
            {
                playerText.geometry.dispose(); // Eliminamos anterior
                    playerText.geometry = new THREE.TextGeometry(name + " " + points, {
                        font: loadfont,
                        size: 0.5,
                        height: 0.1,
                        curveSegments: 12, // Suavidad
                        bevelEnabled: true, // biselado para el borde
                        bevelThickness: 0.03,
                        bevelSize: 0.02,
                        bevelSegments: 5
                    });
            }
        }

        function checkIfLost() {
            if (sphere.position.x > 10.5) {
                pointsPlayer++;
                reprint("Player X", pointsPlayer);
                if (pointsPlayer >= 3)
                {
                    alert("¡Felicidades! " + "player X" + " ha ganado la partida de pong.");
                    pointsIA = 0;
                    pointsPlayer = 0;
                    reprint("Player X", pointsPlayer);
                    reprint("IA", pointsPlayer);

                }
                resetBall();
            }
            if (sphere.position.x < -10.5) {
                pointsIA++;
                reprint("IA", pointsIA);
                if (pointsIA >= 3)
                {
                    alert("La IA ha ganado la partida de pong");
                    pointsIA = 0;
                    pointsPlayer = 0;
                    reprint("Player X", pointsPlayer);
                    reprint("IA", pointsPlayer);
                }
                resetBall();
            }
        }

        function checkPaddleCollision() {
            // Colisión con la pala izquierda
            if (sphere.position.x <= paddleLeft.position.x + 0.2 &&
                sphere.position.y >= paddleLeft.position.y - 1 &&
                sphere.position.y <= paddleLeft.position.y + 1) {
                ballSpeedX *= -1;
                ballSpeedX += 0.025;
                ballSpeedY += 0.017;
            }

            // Colisión con la pala derecha
            if (sphere.position.x >= paddleRight.position.x - 0.2 &&
                sphere.position.y >= paddleRight.position.y - 1 &&
                sphere.position.y <= paddleRight.position.y + 1) {
                ballSpeedX *= -1;
                ballSpeedX += 0.025;
                ballSpeedY += 0.017;
            }
        }

        function moveAI() {
            const aiPosition = paddleRight.position.y;
            const ballPosition = sphere.position.y;

            if (ballPosition > aiPosition + 0.5 && aiPosition < 3) {
                paddleRight.position.y += aiSpeed;
            } else if (ballPosition < aiPosition - 0.5 && aiPosition > -3) {
                paddleRight.position.y -= aiSpeed;
            }
        }

        window.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'w':
                    movePaddleLeft = 1; // Mover hacia arriba
                    break;
                case 's':
                    movePaddleLeft = -1; // Mover hacia abajo
                    break;
            }
        });

        window.addEventListener('keyup', (event) => {
            if (event.key === 'w' || event.key === 's') {
                movePaddleLeft = 0; // Detener movimiento
            }
        });

        // Ajustar la escena al redimensionar la ventana
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
