<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong Palas con Three.js</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Crear la escena
        const scene = new THREE.Scene();

        // Crear la cámara
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 10; // Aumentar la distancia de la cámara

        // Crear el renderer
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Crear la esfera (pelota)
        const sphereGeometry = new THREE.SphereGeometry(0.3, 27, 27);
        const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0x87CEEB, metalness: 0.5, roughness: 0.5 });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.position.set(0, 0, 0);
        scene.add(sphere);

        // Crear las palas
        const paddleGeometry = new THREE.BoxGeometry(0.2, 2, 0.1);
        const paddleMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });

        // Crear pala izquierda
        const paddleLeft = new THREE.Mesh(paddleGeometry, paddleMaterial);
        paddleLeft.position.x = -10; 
        paddleLeft.position.y = 0; 
        scene.add(paddleLeft);

        // Crear pala derecha
        const paddleRight = new THREE.Mesh(paddleGeometry, paddleMaterial);
        paddleRight.position.x = 10; 
        paddleRight.position.y = 0; 
        scene.add(paddleRight);

        // Crear el borde del rectángulo (zona de juego)
        const borderMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
        const points = [];
        points.push(new THREE.Vector3(-10.5, 5, 0)); // Esquina superior izquierda
        points.push(new THREE.Vector3(10.5, 5, 0)); // Esquina superior derecha
        points.push(new THREE.Vector3(10.5, 5, 0)); // Esquina superior derecha
        points.push(new THREE.Vector3(10.5, -5, 0)); // Esquina inferior derecha
        points.push(new THREE.Vector3(10.5, -5, 0)); // Esquina inferior derecha
        points.push(new THREE.Vector3(-10.5, -5, 0)); // Esquina inferior izquierda
        points.push(new THREE.Vector3(-10.5, -5, 0)); // Esquina inferior izquierda
        points.push(new THREE.Vector3(-10.5, 5, 0)); // Esquina superior izquierda

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const border = new THREE.LineSegments(geometry, borderMaterial);
        scene.add(border);

        // Añadir luz
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        // Variables para la lógica del juego
        let ballSpeedX = 0.15; // Velocidad de la bola en el eje X
        let ballSpeedY = 0.1; // Velocidad de la bola en el eje Y

        // Variables para la IA
        const aiSpeed = 0.1;

        // Función de animación
        function animate() {
            requestAnimationFrame(animate);

            // Actualizar la posición de la bola
            sphere.position.x += ballSpeedX;
            sphere.position.y += ballSpeedY;

            // Verificar si se ha perdido un punto
            checkIfLost();

            // Colisiones con los bordes del campo
            if (sphere.position.y > 5 || sphere.position.y < -5) {
                ballSpeedY *= -1; // Invertir la dirección Y
            }

            // Colisiones con las palas
            checkPaddleCollision();

            // Movimiento de la IA
            moveAI();

            // Limitar el movimiento de las palas
            paddleLeft.position.y = THREE.MathUtils.clamp(paddleLeft.position.y, -3, 3);
            paddleRight.position.y = THREE.MathUtils.clamp(paddleRight.position.y, -3, 3);

            renderer.render(scene, camera);
        }
        animate();

        function resetBall() {
            sphere.position.set(0, 0, 0);
            ballSpeedX = -ballSpeedX; // Cambiar dirección
        }

        function checkIfLost() {
            if (sphere.position.x > 10.5) {
                alert("¡Punto para el jugador 1!");
                resetBall();
            }
            if (sphere.position.x < -10.5) {
                alert("¡Punto para el jugador 2!");
                resetBall();
            }
        }

        function checkPaddleCollision() {
            // Colisión con la pala izquierda
            if (sphere.position.x <= paddleLeft.position.x + 0.2 &&
                sphere.position.y >= paddleLeft.position.y - 1 &&
                sphere.position.y <= paddleLeft.position.y + 1) {
                ballSpeedX *= -1; // Invertir la dirección X
                ballSpeedX += 0.01; // Incrementar la velocidad en X
                ballSpeedY += 0.01; // Incrementar la velocidad en Y
            }

            // Colisión con la pala derecha
            if (sphere.position.x >= paddleRight.position.x - 0.2 &&
                sphere.position.y >= paddleRight.position.y - 1 &&
                sphere.position.y <= paddleRight.position.y + 1) {
                ballSpeedX *= -1; // Invertir la dirección X
                ballSpeedX += 0.01; // Incrementar la velocidad en X
                ballSpeedY += 0.01; // Incrementar la velocidad en Y
            }
        }

        function moveAI() {
            const aiPosition = paddleRight.position.y;
            const ballPosition = sphere.position.y;

            if (ballPosition > aiPosition + 0.5 && aiPosition < 3) {
                paddleRight.position.y += aiSpeed;
            } else if (ballPosition < aiPosition - 0.5 && aiPosition > -3) {
                paddleRight.position.y -= aiSpeed;
            }
        }

        // Control de las palas con teclado
        window.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'w': // Mover la pala izquierda hacia arriba
                    paddleLeft.position.y += 0.5;
                    break;
                case 's': // Mover la pala izquierda hacia abajo
                    paddleLeft.position.y -= 0.5;
                    break;
                case 'ArrowUp': // Mover la pala derecha hacia arriba
                    paddleRight.position.y += 0.5;
                    break;
                case 'ArrowDown': // Mover la pala derecha hacia abajo
                    paddleRight.position.y -= 0.5;
                    break;
            }
        });

        // Ajustar la escena al redimensionar la ventana
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
